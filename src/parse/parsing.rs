use super::c_ast::{Stmt, Expr};
use crate::lex::{Token, TokenType};

pub struct Parser {
    /// Vector of tokens generated by Lexer
    tokens: Vec<Token>,
    /// Current position in the token vector
    current: usize,
}

impl Parser {
    pub fn new(tokens: Vec<Token>) -> Self {
        Self {
            tokens,
            current: 0,
        }
    }

    pub fn parse(&mut self) -> Result<Stmt, ParseError> {
        let body = self.function()?;
        Ok(Stmt::Program {
            body:Box::new(body)
        })
    }

    fn function(&mut self) -> Result<Stmt, ParseError> {
        // Consume int
        _=self.consume(TokenType::Int, ParseError::ExpectedType)?;
        // Get identifier
        let identifier = self.consume(TokenType::Identifier, ParseError::ExpectedIdentifier)?;
        let name = match identifier.lexeme {
            None => {return Err(ParseError::ExpectedIdentifier)}
            Some(name) => {name}
        };
        let name_expr = Box::new(Expr::Identifier {value: name});
        // Consume left paren
        _=self.consume(TokenType::LeftParen, ParseError::ExpectedLeftParen)?;
        // Consume void
        _=self.consume(TokenType::Void, ParseError::InvalidParams)?;
        // Consume right paren
        _=self.consume(TokenType::RightParen, ParseError::UnmatchedParen)?;
        // Consume left bracket
        _=self.consume(TokenType::LeftBrace, ParseError::ExpectedLeftBrace)?;
        // Parse statement
        let body = Box::new(self.statement()?);
        // Consume right bracket
        _=self.consume(TokenType::RightBrace, ParseError::UnmatchedBrace)?;
        Ok(Stmt::FuncDef {
            name:name_expr, body,
        })
    }

    fn statement(&mut self) -> Result<Stmt, ParseError> {
        // Consume return
        _=self.consume(TokenType::Return, ParseError::ExpectedReturn)?;
        let expression = self.expression()?;
        // consume semicolon
        _=self.consume(TokenType::Semicolon, ParseError::ExpectedSemicolon)?;
        Ok(Stmt::Return {value: Box::new(expression)})
    }

    fn expression(&mut self) -> Result<Expr, ParseError> {
        // Parse int (only current expression)
        let int = self.int()?;
        Ok(int)
    }

    fn int(&mut self) -> Result<Expr, ParseError> {
        let token = self.advance();
        let value = match &token.token_type {
            TokenType::Constant => {
                match token.lexeme {
                    None => {return Err(ParseError::InvalidInt)}
                    Some(v) => {v}
                }
            }
            _=> {return Err(ParseError::UnexpectedToken);}
        };
        Ok(Expr::new_int(&value))
    }
    
    // region helper functions
    
    fn peek(&self)->Token{
        self.tokens[self.current].clone()
    }
    
    fn is_at_end(&self)->bool{
        self.current >= self.tokens.len()
    }
    
    fn previous(&self) -> Token {
        self.tokens[self.current-1].clone()
    }
    
    fn advance(&mut self) -> Token {
        if !self.is_at_end() {
            self.current += 1;
        }
        self.previous()
    }
    
    fn consume(&mut self, token_type: TokenType, error: ParseError) -> Result<Token, ParseError>{
        if self.check(token_type) {Ok(self.advance())} else {
            Err(error)
        }
    }
    
    fn check(&self, token_type: TokenType)->bool {
        if self.is_at_end() {false} else {
            self.peek().token_type == token_type
        }
    }
}


#[derive(Debug)]
pub enum ParseError {
    UnmatchedParen,
    UnmatchedBrace,
    ExpectedIdentifier,
    ExpectedSemicolon,
    ExpectedType,
    ExpectedLeftParen,
    ExpectedLeftBrace,
    ExpectedReturn,
    InvalidParams,
    InvalidInt,
    UnexpectedToken,
}

#[cfg(test)]
mod tests {
    use crate::lex;
    use super::*;
    #[test]
    fn test_parser() {
        // Create test source code
        let source_code = "int main(void){return 2;}";
        // Create lex
        let mut lexer = lex::Lexer::new(source_code.to_string());
        // Tokenize the input source code
        let tokens = lexer.tokenize().unwrap();
        // Create parse
        let mut parser = Parser::new(tokens);
        // Parse the source code
        let ast = parser.parse().unwrap();
        // Check that the top level of the ast is a program
        assert!(
            match ast {
                Stmt::Program { body } => {
                    match *body {
                        Stmt::FuncDef { name, body } => {
                            let name_ok = match *name {
                                Expr::Identifier { value } => {
                                    value == "main"
                                }
                                _=>false,
                            };
                            name_ok && match *body {
                                Stmt::Return { value } => {
                                    match *value {
                                        Expr::IntConstant { value } => {
                                            value == 2
                                        }
                                        _ => {false}
                                    }
                                },
                                _=> false,
                            }
                        }
                        _=>false,
                    }
                },
                _ => false,
            }
        )
    }
}
